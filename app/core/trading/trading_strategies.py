"""
Automated Trading Strategies

Advanced trading strategy system implementing:
- Mean reversion strategy
- Momentum trading
- Arbitrage detection
- DCA (Dollar Cost Averaging)
- Risk-managed position sizing
- Multi-timeframe analysis
- Strategy performance tracking
"""

import asyncio
import json
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from enum import Enum
from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod
import statistics

from ...dependencies import get_redis
from ..market.market_data import market_data_service
from ..agents.agent_manager import agent_manager
from ..agents.collective_intelligence import collective_intelligence

logger = logging.getLogger(__name__)


class StrategyType(str, Enum):
    """Trading strategy types"""
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    ARBITRAGE = "arbitrage"
    DCA = "dca"
    GRID_TRADING = "grid_trading"
    SCALPING = "scalping"
    SWING = "swing"
    BREAKOUT = "breakout"


class SignalType(str, Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class RiskLevel(str, Enum):
    """Risk levels for strategies"""
    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""
    strategy_id: str
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    price: float
    quantity: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    reasoning: str = ""
    timestamp: str = ""
    expiry: Optional[str] = None
    metadata: Dict[str, Any] = None


@dataclass
class StrategyConfig:
    """Strategy configuration"""
    strategy_id: str
    name: str
    strategy_type: StrategyType
    symbols: List[str]
    enabled: bool = True
    risk_level: RiskLevel = RiskLevel.MODERATE
    parameters: Dict[str, Any] = None
    max_position_size: float = 1000.0
    max_daily_trades: int = 10
    stop_loss_pct: float = 0.02  # 2%
    take_profit_pct: float = 0.04  # 4%
    min_confidence: float = 0.6


@dataclass
class StrategyPerformance:
    """Strategy performance metrics"""
    strategy_id: str
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    profit_factor: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    last_updated: str = ""


class TradingStrategy(ABC):
    """Abstract base class for trading strategies"""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.performance = StrategyPerformance(strategy_id=config.strategy_id)
        self.positions: Dict[str, Dict[str, Any]] = {}
        self.last_prices: Dict[str, float] = {}
        self.signals_generated = 0
        
    @abstractmethod
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate trading signal for symbol"""
        pass
        
    @abstractmethod
    async def update_position(self, symbol: str, trade_data: Dict[str, Any]):
        """Update position after trade execution"""
        pass
        
    async def should_trade(self, signal: TradingSignal) -> bool:
        """Check if signal meets trading criteria"""
        # Check minimum confidence
        if signal.confidence < self.config.min_confidence:
            return False
            
        # Check daily trade limit
        today = datetime.utcnow().date()
        trades_today = await self._get_trades_today()
        if trades_today >= self.config.max_daily_trades:
            return False
            
        # Check position size limits
        current_position = self.positions.get(signal.symbol, {}).get("quantity", 0)
        if abs(current_position + signal.quantity) > self.config.max_position_size:
            return False
            
        return True
        
    async def calculate_position_size(self, symbol: str, price: float, confidence: float) -> float:
        """Calculate position size based on risk management"""
        # Base position size based on risk level
        risk_multipliers = {
            RiskLevel.CONSERVATIVE: 0.5,
            RiskLevel.MODERATE: 1.0,
            RiskLevel.AGGRESSIVE: 2.0
        }
        
        base_size = self.config.max_position_size * risk_multipliers[self.config.risk_level]
        
        # Adjust by confidence
        confidence_adjusted = base_size * confidence
        
        # Kelly criterion adjustment (simplified)
        win_rate = self.performance.win_rate if self.performance.win_rate > 0 else 0.5
        avg_win = self.performance.avg_win if self.performance.avg_win > 0 else 0.02
        avg_loss = abs(self.performance.avg_loss) if self.performance.avg_loss < 0 else 0.02
        
        kelly_fraction = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
        kelly_fraction = max(0.1, min(0.25, kelly_fraction))  # Cap between 10% and 25%
        
        final_size = min(confidence_adjusted, base_size * kelly_fraction)
        
        # Ensure minimum trade size
        return max(final_size, 100.0)
        
    async def _get_trades_today(self) -> int:
        """Get number of trades executed today"""
        # This would query actual trade history
        return 0  # Placeholder
        

class MeanReversionStrategy(TradingStrategy):
    """Mean reversion trading strategy"""
    
    def __init__(self, config: StrategyConfig):
        super().__init__(config)
        
        # Default parameters
        default_params = {
            "lookback_period": 20,
            "std_dev_threshold": 2.0,
            "rsi_oversold": 30,
            "rsi_overbought": 70,
            "bollinger_period": 20,
            "bollinger_std": 2.0
        }
        
        self.params = {**default_params, **(config.parameters or {})}
        
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate mean reversion signal"""
        try:
            # Get historical data
            historical_data = await market_data_service.get_historical_data(
                symbol, "30d", "1h"
            )
            
            if historical_data is None or len(historical_data) < self.params["lookback_period"]:
                return None
                
            # Get technical indicators
            indicators = await market_data_service.get_technical_indicators(symbol)
            current_price = market_data.get("price", indicators.get("current_price"))
            
            if not current_price:
                return None
                
            # Calculate signals
            signals = []
            
            # RSI-based signal
            rsi = indicators.get("rsi", 50)
            if rsi < self.params["rsi_oversold"]:
                signals.append(("rsi_oversold", 0.8))
            elif rsi > self.params["rsi_overbought"]:
                signals.append(("rsi_overbought", 0.8))
                
            # Bollinger Bands signal
            bb_upper = indicators.get("bb_upper")
            bb_lower = indicators.get("bb_lower")
            bb_middle = indicators.get("bb_middle")
            
            if bb_upper and bb_lower and bb_middle:
                if current_price < bb_lower:
                    signals.append(("bb_oversold", 0.7))
                elif current_price > bb_upper:
                    signals.append(("bb_overbought", 0.7))
                    
            # Price deviation from mean
            closes = historical_data['Close'].values
            mean_price = np.mean(closes[-self.params["lookback_period"]:])
            std_price = np.std(closes[-self.params["lookback_period"]:])
            
            z_score = (current_price - mean_price) / std_price if std_price > 0 else 0
            
            if z_score < -self.params["std_dev_threshold"]:
                signals.append(("price_undervalued", 0.6))
            elif z_score > self.params["std_dev_threshold"]:
                signals.append(("price_overvalued", 0.6))
                
            if not signals:
                return None
                
            # Determine signal type and confidence
            buy_signals = [s for s in signals if s[0] in ["rsi_oversold", "bb_oversold", "price_undervalued"]]
            sell_signals = [s for s in signals if s[0] in ["rsi_overbought", "bb_overbought", "price_overvalued"]]
            
            if buy_signals and len(buy_signals) >= len(sell_signals):
                signal_type = SignalType.BUY
                confidence = min(1.0, sum(s[1] for s in buy_signals) / len(buy_signals))
                reasoning = f"Mean reversion buy: {', '.join(s[0] for s in buy_signals)}"
            elif sell_signals:
                signal_type = SignalType.SELL
                confidence = min(1.0, sum(s[1] for s in sell_signals) / len(sell_signals))
                reasoning = f"Mean reversion sell: {', '.join(s[0] for s in sell_signals)}"
            else:
                return None
                
            # Calculate position size
            quantity = await self.calculate_position_size(symbol, current_price, confidence)
            
            # Set stop loss and take profit
            if signal_type == SignalType.BUY:
                stop_loss = current_price * (1 - self.config.stop_loss_pct)
                take_profit = current_price * (1 + self.config.take_profit_pct)
            else:
                stop_loss = current_price * (1 + self.config.stop_loss_pct)
                take_profit = current_price * (1 - self.config.take_profit_pct)
                quantity = -quantity  # Negative for sell
                
            return TradingSignal(
                strategy_id=self.config.strategy_id,
                symbol=symbol,
                signal_type=signal_type,
                confidence=confidence,
                price=current_price,
                quantity=quantity,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reasoning=reasoning,
                timestamp=datetime.utcnow().isoformat(),
                metadata={"rsi": rsi, "z_score": z_score, "signals": signals}
            )
            
        except Exception as e:
            logger.error(f"Error generating mean reversion signal for {symbol}: {e}")
            return None
            
    async def update_position(self, symbol: str, trade_data: Dict[str, Any]):
        """Update position after trade execution"""
        if symbol not in self.positions:
            self.positions[symbol] = {"quantity": 0, "avg_price": 0}
            
        position = self.positions[symbol]
        
        trade_quantity = trade_data.get("quantity", 0)
        trade_price = trade_data.get("price", 0)
        
        # Update position
        if position["quantity"] == 0:
            position["quantity"] = trade_quantity
            position["avg_price"] = trade_price
        else:
            total_cost = position["quantity"] * position["avg_price"] + trade_quantity * trade_price
            total_quantity = position["quantity"] + trade_quantity
            
            if total_quantity != 0:
                position["avg_price"] = total_cost / total_quantity
                position["quantity"] = total_quantity
            else:
                position["quantity"] = 0
                position["avg_price"] = 0


class MomentumStrategy(TradingStrategy):
    """Momentum trading strategy"""
    
    def __init__(self, config: StrategyConfig):
        super().__init__(config)
        
        default_params = {
            "momentum_period": 10,
            "momentum_threshold": 0.02,  # 2%
            "volume_threshold": 1.5,  # 1.5x average volume
            "macd_fast": 12,
            "macd_slow": 26,
            "macd_signal": 9
        }
        
        self.params = {**default_params, **(config.parameters or {})}
        
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate momentum signal"""
        try:
            # Get historical data
            historical_data = await market_data_service.get_historical_data(
                symbol, "30d", "1h"
            )
            
            if historical_data is None or len(historical_data) < self.params["momentum_period"]:
                return None
                
            # Get technical indicators
            indicators = await market_data_service.get_technical_indicators(symbol)
            current_price = market_data.get("price", indicators.get("current_price"))
            current_volume = market_data.get("volume", 0)
            
            if not current_price:
                return None
                
            # Calculate momentum
            closes = historical_data['Close'].values
            momentum = (current_price - closes[-self.params["momentum_period"]]) / closes[-self.params["momentum_period"]]
            
            # Calculate average volume
            volumes = historical_data['Volume'].values
            avg_volume = np.mean(volumes[-20:])  # 20-period average
            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1
            
            # MACD signal
            macd = indicators.get("macd", 0)
            macd_signal = indicators.get("macd_signal", 0)
            macd_diff = indicators.get("macd_diff", 0)
            
            # Generate signals
            signals = []
            
            # Momentum signal
            if momentum > self.params["momentum_threshold"]:
                signals.append(("positive_momentum", 0.7))
            elif momentum < -self.params["momentum_threshold"]:
                signals.append(("negative_momentum", 0.7))
                
            # Volume confirmation
            if volume_ratio > self.params["volume_threshold"]:
                signals.append(("high_volume", 0.5))
                
            # MACD confirmation
            if macd > macd_signal and macd_diff > 0:
                signals.append(("macd_bullish", 0.6))
            elif macd < macd_signal and macd_diff < 0:
                signals.append(("macd_bearish", 0.6))
                
            if not signals:
                return None
                
            # Determine signal
            bullish_signals = [s for s in signals if s[0] in ["positive_momentum", "high_volume", "macd_bullish"]]
            bearish_signals = [s for s in signals if s[0] in ["negative_momentum", "macd_bearish"]]
            
            if bullish_signals and len(bullish_signals) >= 2:
                signal_type = SignalType.BUY
                confidence = min(1.0, sum(s[1] for s in bullish_signals) / len(bullish_signals))
                reasoning = f"Momentum buy: {', '.join(s[0] for s in bullish_signals)}"
            elif bearish_signals and len(bearish_signals) >= 2:
                signal_type = SignalType.SELL
                confidence = min(1.0, sum(s[1] for s in bearish_signals) / len(bearish_signals))
                reasoning = f"Momentum sell: {', '.join(s[0] for s in bearish_signals)}"
            else:
                return None
                
            # Calculate position size
            quantity = await self.calculate_position_size(symbol, current_price, confidence)
            
            # Set stop loss and take profit
            if signal_type == SignalType.BUY:
                stop_loss = current_price * (1 - self.config.stop_loss_pct)
                take_profit = current_price * (1 + self.config.take_profit_pct)
            else:
                stop_loss = current_price * (1 + self.config.stop_loss_pct)
                take_profit = current_price * (1 - self.config.take_profit_pct)
                quantity = -quantity
                
            return TradingSignal(
                strategy_id=self.config.strategy_id,
                symbol=symbol,
                signal_type=signal_type,
                confidence=confidence,
                price=current_price,
                quantity=quantity,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reasoning=reasoning,
                timestamp=datetime.utcnow().isoformat(),
                metadata={
                    "momentum": momentum,
                    "volume_ratio": volume_ratio,
                    "macd": macd,
                    "signals": signals
                }
            )
            
        except Exception as e:
            logger.error(f"Error generating momentum signal for {symbol}: {e}")
            return None
            
    async def update_position(self, symbol: str, trade_data: Dict[str, Any]):
        """Update position after trade execution"""
        # Same implementation as MeanReversionStrategy
        if symbol not in self.positions:
            self.positions[symbol] = {"quantity": 0, "avg_price": 0}
            
        position = self.positions[symbol]
        
        trade_quantity = trade_data.get("quantity", 0)
        trade_price = trade_data.get("price", 0)
        
        if position["quantity"] == 0:
            position["quantity"] = trade_quantity
            position["avg_price"] = trade_price
        else:
            total_cost = position["quantity"] * position["avg_price"] + trade_quantity * trade_price
            total_quantity = position["quantity"] + trade_quantity
            
            if total_quantity != 0:
                position["avg_price"] = total_cost / total_quantity
                position["quantity"] = total_quantity
            else:
                position["quantity"] = 0
                position["avg_price"] = 0


class ArbitrageStrategy(TradingStrategy):
    """Arbitrage detection and execution strategy"""
    
    def __init__(self, config: StrategyConfig):
        super().__init__(config)
        
        default_params = {
            "min_spread": 0.005,  # 0.5% minimum spread
            "max_execution_time": 30,  # 30 seconds max
            "cross_exchange": True,
            "same_asset_pairs": ["BTC/USD", "BTC/USDT", "ETH/USD", "ETH/USDT"]
        }
        
        self.params = {**default_params, **(config.parameters or {})}
        
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate arbitrage signal"""
        try:
            # Get prices from multiple providers
            providers = ["yahoo", "twelvedata", "finnhub"]  # Example providers
            prices = {}
            
            for provider in providers:
                try:
                    # This would get price from specific provider
                    # For now, simulate different prices
                    base_price = market_data.get("price", 100)
                    price_variation = np.random.uniform(-0.002, 0.002)  # ±0.2%
                    prices[provider] = base_price * (1 + price_variation)
                except:
                    continue
                    
            if len(prices) < 2:
                return None
                
            # Find arbitrage opportunities
            min_price = min(prices.values())
            max_price = max(prices.values())
            spread = (max_price - min_price) / min_price
            
            if spread < self.params["min_spread"]:
                return None
                
            # Find buy and sell exchanges
            buy_exchange = [k for k, v in prices.items() if v == min_price][0]
            sell_exchange = [k for k, v in prices.items() if v == max_price][0]
            
            confidence = min(1.0, spread / self.params["min_spread"])
            
            # Create arbitrage signal (buy low, sell high)
            quantity = await self.calculate_position_size(symbol, min_price, confidence)
            
            return TradingSignal(
                strategy_id=self.config.strategy_id,
                symbol=symbol,
                signal_type=SignalType.BUY,  # Simplified - would need paired trades
                confidence=confidence,
                price=min_price,
                quantity=quantity,
                reasoning=f"Arbitrage opportunity: {spread:.3%} spread between {buy_exchange} and {sell_exchange}",
                timestamp=datetime.utcnow().isoformat(),
                expiry=(datetime.utcnow() + timedelta(seconds=self.params["max_execution_time"])).isoformat(),
                metadata={
                    "spread": spread,
                    "buy_exchange": buy_exchange,
                    "sell_exchange": sell_exchange,
                    "all_prices": prices
                }
            )
            
        except Exception as e:
            logger.error(f"Error generating arbitrage signal for {symbol}: {e}")
            return None
            
    async def update_position(self, symbol: str, trade_data: Dict[str, Any]):
        """Update arbitrage position"""
        # Arbitrage positions are typically closed quickly
        pass


class DCAStrategy(TradingStrategy):
    """Dollar Cost Averaging strategy"""
    
    def __init__(self, config: StrategyConfig):
        super().__init__(config)
        
        default_params = {
            "investment_amount": 100.0,  # Fixed amount per interval
            "interval_hours": 24,  # Every 24 hours
            "price_drop_threshold": 0.05,  # Additional buy on 5% drop
            "profit_taking_threshold": 0.20,  # Take profit at 20%
            "max_positions": 50  # Maximum number of DCA positions
        }
        
        self.params = {**default_params, **(config.parameters or {})}
        self.last_purchase: Dict[str, datetime] = {}
        
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate DCA signal"""
        try:
            current_price = market_data.get("price")
            if not current_price:
                return None
                
            current_time = datetime.utcnow()
            last_purchase_time = self.last_purchase.get(symbol, datetime.min)
            
            # Check if enough time has passed for regular DCA
            time_since_last = (current_time - last_purchase_time).total_seconds() / 3600
            
            signals = []
            
            # Regular DCA signal
            if time_since_last >= self.params["interval_hours"]:
                signals.append(("regular_dca", 0.8))
                
            # Price drop opportunity
            if symbol in self.last_prices:
                price_change = (current_price - self.last_prices[symbol]) / self.last_prices[symbol]
                if price_change <= -self.params["price_drop_threshold"]:
                    signals.append(("dip_buying", 0.9))
                    
            # Check profit taking
            current_position = self.positions.get(symbol, {})
            if current_position.get("quantity", 0) > 0:
                avg_price = current_position.get("avg_price", current_price)
                profit = (current_price - avg_price) / avg_price
                
                if profit >= self.params["profit_taking_threshold"]:
                    # Sell signal for profit taking
                    return TradingSignal(
                        strategy_id=self.config.strategy_id,
                        symbol=symbol,
                        signal_type=SignalType.SELL,
                        confidence=0.9,
                        price=current_price,
                        quantity=-current_position["quantity"],  # Sell all
                        reasoning=f"DCA profit taking: {profit:.2%} profit",
                        timestamp=current_time.isoformat(),
                        metadata={"profit": profit, "avg_price": avg_price}
                    )
                    
            if not signals:
                return None
                
            # Check position limits
            position_count = len([p for p in self.positions.values() if p.get("quantity", 0) > 0])
            if position_count >= self.params["max_positions"]:
                return None
                
            # Calculate DCA quantity
            quantity = self.params["investment_amount"] / current_price
            
            # Increase quantity for dip buying
            if any(s[0] == "dip_buying" for s in signals):
                quantity *= 1.5  # 50% more on dips
                
            confidence = max(s[1] for s in signals)
            reasoning = f"DCA buy: {', '.join(s[0] for s in signals)}"
            
            return TradingSignal(
                strategy_id=self.config.strategy_id,
                symbol=symbol,
                signal_type=SignalType.BUY,
                confidence=confidence,
                price=current_price,
                quantity=quantity,
                reasoning=reasoning,
                timestamp=current_time.isoformat(),
                metadata={"signals": signals, "investment_amount": self.params["investment_amount"]}
            )
            
        except Exception as e:
            logger.error(f"Error generating DCA signal for {symbol}: {e}")
            return None
            
    async def update_position(self, symbol: str, trade_data: Dict[str, Any]):
        """Update DCA position"""
        await super().update_position(symbol, trade_data)
        
        # Update last purchase time
        if trade_data.get("quantity", 0) > 0:  # Only for buy orders
            self.last_purchase[symbol] = datetime.utcnow()


class StrategyManager:
    """Manages all trading strategies"""
    
    def __init__(self):
        self.strategies: Dict[str, TradingStrategy] = {}
        self.redis = None
        self.running = False
        
    async def initialize(self):
        """Initialize strategy manager"""
        self.redis = await get_redis()
        await self._load_strategies()
        logger.info("Strategy Manager initialized")
        
    async def start(self):
        """Start strategy manager"""
        await self.initialize()
        self.running = True
        
        # Start background tasks
        asyncio.create_task(self._strategy_executor())
        asyncio.create_task(self._performance_tracker())
        
        logger.info("Strategy Manager started")
        
    async def stop(self):
        """Stop strategy manager"""
        self.running = False
        logger.info("Strategy Manager stopped")
        
    async def add_strategy(self, config: StrategyConfig) -> bool:
        """Add a new trading strategy"""
        try:
            strategy_class_map = {
                StrategyType.MEAN_REVERSION: MeanReversionStrategy,
                StrategyType.MOMENTUM: MomentumStrategy,
                StrategyType.ARBITRAGE: ArbitrageStrategy,
                StrategyType.DCA: DCAStrategy
            }
            
            strategy_class = strategy_class_map.get(config.strategy_type)
            if not strategy_class:
                logger.error(f"Unknown strategy type: {config.strategy_type}")
                return False
                
            strategy = strategy_class(config)
            self.strategies[config.strategy_id] = strategy
            
            # Save to Redis
            await self._save_strategy_config(config)
            
            logger.info(f"Strategy {config.strategy_id} added successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error adding strategy: {e}")
            return False
            
    async def remove_strategy(self, strategy_id: str) -> bool:
        """Remove a trading strategy"""
        try:
            if strategy_id in self.strategies:
                del self.strategies[strategy_id]
                
                # Remove from Redis
                await self.redis.delete(f"strategy:config:{strategy_id}")
                
                logger.info(f"Strategy {strategy_id} removed")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error removing strategy: {e}")
            return False
            
    async def get_strategy_performance(self, strategy_id: str) -> Optional[StrategyPerformance]:
        """Get strategy performance metrics"""
        if strategy_id in self.strategies:
            return self.strategies[strategy_id].performance
        return None
        
    async def get_all_strategies(self) -> Dict[str, StrategyConfig]:
        """Get all strategy configurations"""
        return {sid: strategy.config for sid, strategy in self.strategies.items()}
        
    async def _load_strategies(self):
        """Load strategies from Redis"""
        try:
            strategy_keys = await self.redis.keys("strategy:config:*")
            
            for key in strategy_keys:
                config_data = await self.redis.get(key)
                if config_data:
                    config_dict = json.loads(config_data)
                    config = StrategyConfig(**config_dict)
                    
                    if config.enabled:
                        await self.add_strategy(config)
                        
        except Exception as e:
            logger.error(f"Error loading strategies: {e}")
            
    async def _save_strategy_config(self, config: StrategyConfig):
        """Save strategy configuration to Redis"""
        await self.redis.set(
            f"strategy:config:{config.strategy_id}",
            json.dumps(asdict(config), default=str)
        )
        
    async def _strategy_executor(self):
        """Execute strategies and generate signals"""
        while self.running:
            try:
                for strategy_id, strategy in self.strategies.items():
                    if not strategy.config.enabled:
                        continue
                        
                    for symbol in strategy.config.symbols:
                        try:
                            # Get market data
                            quote = await market_data_service.get_quote(symbol)
                            if not quote:
                                continue
                                
                            # Generate signal
                            signal = await strategy.generate_signal(symbol, quote)
                            
                            if signal and await strategy.should_trade(signal):
                                # Request collective decision if enabled
                                if hasattr(collective_intelligence, 'make_collective_decision'):
                                    decision = await collective_intelligence.make_collective_decision(
                                        "trade",
                                        f"{signal.symbol}_{signal.signal_type.value}",
                                        collective_intelligence.ConsensusAlgorithm.WEIGHTED_MAJORITY,
                                        timeout_seconds=10
                                    )
                                    
                                    if decision and decision.result.get("approved", False):
                                        await self._execute_signal(signal)
                                else:
                                    # Execute directly if collective intelligence not available
                                    await self._execute_signal(signal)
                                    
                        except Exception as e:
                            logger.error(f"Error processing strategy {strategy_id} for {symbol}: {e}")
                            
                await asyncio.sleep(10)  # Check every 10 seconds
                
            except Exception as e:
                logger.error(f"Error in strategy executor: {e}")
                await asyncio.sleep(10)
                
    async def _execute_signal(self, signal: TradingSignal):
        """Execute trading signal"""
        try:
            # Create order
            order_data = {
                "symbol": signal.symbol,
                "action": signal.signal_type.value,
                "quantity": abs(signal.quantity),
                "price": signal.price,
                "order_type": "market",
                "strategy_id": signal.strategy_id,
                "stop_loss": signal.stop_loss,
                "take_profit": signal.take_profit,
                "timestamp": signal.timestamp
            }
            
            # Queue order for execution
            await self.redis.lpush("orders:strategy", json.dumps(order_data))
            
            logger.info(f"Signal executed: {signal.strategy_id} {signal.signal_type.value} {signal.symbol}")
            
        except Exception as e:
            logger.error(f"Error executing signal: {e}")
            
    async def _performance_tracker(self):
        """Track strategy performance"""
        while self.running:
            try:
                for strategy_id, strategy in self.strategies.items():
                    # Update performance metrics
                    performance = strategy.performance
                    
                    if performance.total_trades > 0:
                        performance.win_rate = performance.winning_trades / performance.total_trades
                        
                        if performance.losing_trades > 0:
                            performance.profit_factor = abs(performance.avg_win * performance.winning_trades) / abs(performance.avg_loss * performance.losing_trades)
                            
                    performance.last_updated = datetime.utcnow().isoformat()
                    
                    # Save performance to Redis
                    await self.redis.hset(
                        f"strategy:performance:{strategy_id}",
                        mapping={k: str(v) for k, v in asdict(performance).items()}
                    )
                    
                await asyncio.sleep(60)  # Update every minute
                
            except Exception as e:
                logger.error(f"Error in performance tracker: {e}")
                await asyncio.sleep(60)


# Global strategy manager instance
strategy_manager = StrategyManager()